# ==============================================================================
# Backend.AI RBAC GraphQL Schema
# ==============================================================================
# Author: Sanghun Lee (sanghun@lablup.com)
# Status: Draft
# Created: 2025-11-12
#
# This schema provides the GraphQL API specification for Backend.AI's
# Role-Based Access Control (RBAC) system. The API enables fine-grained
# permission management across all entity types in Backend.AI through a
# unified and consistent interface.
#
# Following BEP-1012 RBAC Feature Specification, this schema provides the
# GraphQL API definition for managing roles in the RBAC system.
#
# Key Features:
# - Unified Permission Management: Single GraphQL interface for managing
#   permissions across all entity types
# - Flexible Role Definition: Create and manage custom roles with
#   fine-grained permissions
# - Cross-Scope Collaboration: Share resources and grant permissions
#   across different scopes
#
# References:
# - BEP-1012 RBAC Feature Specification: ../BEP-1012-RBAC-feature-spec.md
# - GraphQL Specification: https://spec.graphql.org/
# ==============================================================================

# ==============================================================================
# Scalar Types
# ==============================================================================

"""
DateTime scalar type represents date and time in ISO 8601 format
"""
scalar DateTime

"""
JSONString scalar type represents arbitrary JSON data
"""
scalar JSONString

# ==============================================================================
# Enums
# ==============================================================================

"""
Entity types managed by the RBAC system.

These are all the resource types that can have permissions defined for them.
Each entity type can be referenced in both ScopedPermissions (for type-level
access) and ObjectPermissions (for instance-level access).
"""
enum EntityType {
  COMPUTE_SESSION
  VFOLDER
  IMAGE
  MODEL_SERVICE
  MODEL_ARTIFACT
  AGENT
  RESOURCE_GROUP
  STORAGE_HOST
  APP_CONFIG
  NOTIFICATION
  DOMAIN
  PROJECT
  USER
  ROLE
  ROLE_ASSIGNMENT
}

"""
Operations that can be performed on entities.

All entity types support the same set of operations for consistency:
- CREATE: Create new entities of this type
- READ: View entity information and metadata
- UPDATE: Modify entity properties and settings
- SOFT_DELETE: Mark entity as deleted without removing data (default deletion)
- HARD_DELETE: Permanently remove entity data

Note: Soft-delete changes the entity's state without removing underlying data,
allowing recovery. Hard-delete removes the actual data (though database records
may be retained for audit purposes).
"""
enum OperationType {
  CREATE
  READ
  UPDATE
  SOFT_DELETE
  HARD_DELETE
}

"""
Scope types in the permission hierarchy.

Backend.AI uses a four-level scope hierarchy:
- GLOBAL: System-wide resources and permissions
- DOMAIN: Organizational units within the system
- PROJECT: Collaborative workspaces within domains
- USER: Individual user's private resources

Important: Permissions do NOT cascade to child scopes. Each scope is managed
independently by its respective administrators.
"""
enum ScopeType {
  GLOBAL
  DOMAIN
  PROJECT
  USER
}

"""
Role source indicating how the role was created.

SYSTEM roles:
- Automatically created when a scope is created
- Cannot be individually deleted (lifecycle tied to scope)
- Examples: Domain Admin, Project Admin, User Owner

CUSTOM roles:
- Manually created by administrators
- Can be freely created, modified, and deleted
- Tailored to specific organizational requirements
"""
enum RoleSource {
  """System-generated role (Domain Admin, Project Admin, User Owner)"""
  SYSTEM

  """User-created custom role"""
  CUSTOM
}

"""
Order direction for sorting query results
"""
enum OrderDirection {
  ASC
  DESC
}

"""
Fields available for ordering role queries
"""
enum RoleOrderField {
  NAME
  CREATED_AT
  UPDATED_AT
}

# ==============================================================================
# Permission Types
# ==============================================================================

"""
Scoped Permission: Grants permission for an operation on ALL entities
of a specific type within a scope.

Format: entity_type:operation
Example: "vfolder:read" allows reading all VFolders in the scope

Use Cases:
- Team-wide access to resource types
- Standard role definitions (e.g., "Project Member" can create sessions)
- Scope-level resource management

Key Characteristics:
- Applies to all entities of the specified type within the role's scope
- Does NOT cascade to child scopes
- Efficient for broad access patterns
"""
type ScopedPermission {
  """Entity type this permission applies to"""
  entityType: EntityType!

  """Operation allowed by this permission"""
  operation: OperationType!
}

"""
Input type for creating scoped permissions
"""
input ScopedPermissionInput {
  entityType: EntityType!
  operation: OperationType!
}

"""
Object Permission: Grants permission for an operation on a SPECIFIC entity instance.

Format: entity_type:entity_id:operation
Example: "vfolder:abc-123:read" allows reading only that specific VFolder

Use Cases:
- Sharing individual resources with specific users
- Cross-scope collaboration (sharing personal VFolder with project team)
- Fine-grained access control for sensitive resources

Key Characteristics:
- Applies only to the specific entity instance
- Can reference entities from different scopes (enables cross-scope sharing)
- When object permissions reference entities in other scopes, those scopes
  are automatically added to the role's additionalScopes field
- Attached directly to a Role, independent of the Role's scope binding

Cross-Scope Sharing Example:
When a Role bound to User-A scope includes Object Permissions for a VFolder
in Project-B scope, Project-B is automatically added to additionalScopes.
This enables scenarios like:
- Sharing a personal VFolder with project team members
- Granting access to a specific session across projects
- Collaborative workflows spanning multiple scopes
"""
type ObjectPermission {
  """Entity type this permission applies to"""
  entityType: EntityType!

  """Specific entity ID this permission applies to"""
  entityId: ID!

  """Operation allowed by this permission"""
  operation: OperationType!
}

"""
Input type for creating object permissions
"""
input ObjectPermissionInput {
  entityType: EntityType!
  entityId: ID!
  operation: OperationType!
}

# ==============================================================================
# Scope Types
# ==============================================================================

"""
Scope represents a level in the permission hierarchy.

Every Role is bound to exactly one scope, which defines where the Role's
scoped permissions apply. Object permissions can reference entities from
any scope, enabling cross-scope sharing.
"""
type Scope {
  """Type of scope (GLOBAL, DOMAIN, PROJECT, USER)"""
  type: ScopeType!

  """
  ID of the scope entity (null for GLOBAL scope).
  For DOMAIN, PROJECT, and USER scopes, this references the entity ID.
  """
  id: ID
}

"""
Input type for specifying a scope in mutations
"""
input ScopeInput {
  type: ScopeType!
  id: ID
}

# ==============================================================================
# Core RBAC Entity: Role
# ==============================================================================

"""
Role: Defines a collection of permissions bound to a specific scope.

A Role is the fundamental building block of the RBAC system. It combines:
1. A scope binding (defines where scoped permissions apply)
2. Scoped permissions (type-level access within the scope)
3. Object permissions (instance-level access, can span scopes)

System Sourced Roles (automatically created):
- Domain Admin: Administrator role for domain scope
- Project Admin: Administrator role for project scope
- User Owner: Default role for user scope (for owned and shared resources)

Custom Roles (user-created):
- Tailored to specific organizational requirements
- Can be freely created, modified, and deleted
- Examples: "Project-A-Viewer", "ML-Team-Member", "Dataset-X-Editor"

Role Structure Example:
  Role "Project-A-Member":
  ├─ scope: { type: PROJECT, id: "project-a" }
  ├─ scopedPermissions: [
  │   { entityType: VFOLDER, operation: READ },
  │   { entityType: COMPUTE_SESSION, operation: CREATE }
  │  ]
  ├─ objectPermissions: [
  │   { entityType: MODEL_SERVICE, entityId: "model-x", operation: READ }
  │  ]
  └─ additionalScopes: [{ type: USER, id: "owner-of-model-x" }]

Permission Conflict Resolution:
When a user has multiple roles, the system uses a union (additive) model:
- All permissions from all roles are combined
- If any role grants a permission, the user has that permission
- There is no "deny" mechanism
"""
type Role {
  """Unique identifier"""
  id: ID!

  """
  Human-readable role name.

  Naming conventions:
  - Good: "Project-A-Admin", "Domain-X-Viewer", "VFolder-Y-Editor"
  - Bad: "role1", "temp", "test"

  Must be unique within the scope.
  """
  name: String!

  """
  Optional description of the role's purpose.
  Helps administrators understand the role's intent and usage.
  """
  description: String

  """
  Scope this role is bound to.
  Defines where the role's scoped permissions apply.
  """
  scope: Scope!

  """
  Indicates whether the role is system-generated or custom-created.
  SYSTEM roles cannot be deleted but can be modified.
  """
  source: RoleSource!

  """
  Scoped permissions: entity type + operation.
  These apply to all entities of the specified type within the role's scope.
  """
  scopedPermissions: [ScopedPermission!]!

  """
  Object permissions: entity type + entity ID + operation.
  These apply only to specific entity instances and can span scopes.
  """
  objectPermissions: [ObjectPermission!]!

  """
  Additional scopes where this role has object permissions.
  Automatically populated when object permissions reference entities
  from different scopes.

  Example: If a Role bound to Project-A includes object permissions for
  a VFolder in User-B's scope, User-B's scope appears here.

  Note: This is metadata only. It does NOT grant scoped permissions in
  those scopes, only access to the specific objects listed in
  objectPermissions.
  """
  additionalScopes: [Scope!]!

  """User ID who created this role (null for system-generated roles)"""
  createdById: ID

  """Timestamp when role was created"""
  createdAt: DateTime!

  """Timestamp when role was last updated"""
  updatedAt: DateTime!

  """
  Timestamp when role was deleted (null if active).
  Soft-deleted roles can be reactivated by authorized administrators.
  """
  deletedAt: DateTime
}

# ==============================================================================
# Connection Types (for Pagination)
# ==============================================================================

"""
Connection for paginated role results.
Implements the Relay cursor-based pagination specification.
"""
type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
Edge type for role connections
"""
type RoleEdge {
  node: Role!
  cursor: String!
}

"""
Pagination information following Relay specification
"""
type PageInfo {
  """Whether there are more results after this page"""
  hasNextPage: Boolean!

  """Whether there are results before this page"""
  hasPreviousPage: Boolean!

  """Cursor of the first item in this page"""
  startCursor: String

  """Cursor of the last item in this page"""
  endCursor: String
}

# ==============================================================================
# Filter and Order Input Types
# ==============================================================================

"""
Filter options for role queries.

All filters are ANDed together. Omitted filters are not applied.

Examples:
1. Find all custom roles in a project:
   { scopeType: PROJECT, scopeId: "proj-uuid", source: CUSTOM }

2. Find roles with VFolder permissions:
   { hasPermissionFor: VFOLDER }

3. Find roles with "admin" in the name:
   { nameContains: "admin" }
"""
input RoleFilter {
  """Filter by scope type (GLOBAL, DOMAIN, PROJECT, USER)"""
  scopeType: ScopeType

  """Filter by scope ID (must be used with scopeType)"""
  scopeId: ID

  """Filter by role source (SYSTEM or CUSTOM)"""
  source: RoleSource

  """Filter by roles whose name contains this string (case-insensitive)"""
  nameContains: String

  """
  Filter by roles that have any permission (scoped or object) for this entity type.
  Useful for finding all roles that can access a specific resource type.
  """
  hasPermissionFor: EntityType
}

"""
Ordering options for role queries
"""
input RoleOrderBy {
  """Field to order by"""
  field: RoleOrderField!

  """Sort direction"""
  direction: OrderDirection!
}

# ==============================================================================
# Mutation Input Types
# ==============================================================================

"""
Input for creating a new custom role.

Best Practices:
1. Use descriptive names: "Project-A-Viewer" not "role1"
2. Prefer scoped permissions for team-wide access
3. Use object permissions for specific resource sharing
4. Include a clear description of the role's purpose

Example - Team Role:
  {
    name: "ML-Team-Member",
    description: "Standard member access for ML team",
    scope: { type: PROJECT, id: "ml-project" },
    scopedPermissions: [
      { entityType: VFOLDER, operation: READ },
      { entityType: COMPUTE_SESSION, operation: CREATE }
    ]
  }

Example - Resource-Specific Role:
  {
    name: "Dataset-X-Editor",
    description: "Edit access to Dataset X",
    scope: { type: USER, id: "owner-uuid" },
    objectPermissions: [
      { entityType: VFOLDER, entityId: "dataset-x", operation: READ },
      { entityType: VFOLDER, entityId: "dataset-x", operation: UPDATE }
    ]
  }
"""
input CreateRoleInput {
  """Role name (must be unique within scope)"""
  name: String!

  """Optional description of the role's purpose"""
  description: String

  """Scope to bind this role to"""
  scope: ScopeInput!

  """
  Scoped permissions to include.
  These grant access to all entities of the specified types within the scope.
  """
  scopedPermissions: [ScopedPermissionInput!]

  """
  Object permissions to include.
  These grant access to specific entity instances, can span scopes.
  """
  objectPermissions: [ObjectPermissionInput!]
}

"""
Input for updating an existing role.

Notes:
- All fields except 'id' are optional
- Providing scopedPermissions or objectPermissions REPLACES the existing list
- To add/remove individual permissions, fetch the role, modify locally, then update
- System sourced roles can be modified but not deleted

Example - Update name and description only:
  {
    id: "role-uuid",
    name: "New Name",
    description: "New description"
  }

Example - Replace all permissions:
  {
    id: "role-uuid",
    scopedPermissions: [
      { entityType: VFOLDER, operation: READ },
      { entityType: VFOLDER, operation: UPDATE }
    ]
  }
"""
input UpdateRoleInput {
  """Role ID to update"""
  id: ID!

  """New name (optional)"""
  name: String

  """New description (optional)"""
  description: String

  """
  Replace scoped permissions (optional).
  If provided, completely replaces the existing scoped permissions.
  """
  scopedPermissions: [ScopedPermissionInput!]

  """
  Replace object permissions (optional).
  If provided, completely replaces the existing object permissions.
  """
  objectPermissions: [ObjectPermissionInput!]
}

# ==============================================================================
# (No separate payload types - mutations return Role directly)
# ==============================================================================

# ==============================================================================
# Root Query Type
# ==============================================================================

"""
Root query type for RBAC operations.

Query Examples:

1. Get a specific role:
   query {
     role(id: "role-uuid") {
       id
       name
       description
       source
       scope {
         type
         id
       }
       scopedPermissions {
         entityType
         operation
       }
       objectPermissions {
         entityType
         entityId
         operation
       }
     }
   }

2. List all custom roles in a project:
   query {
     roles(
       filter: { scopeType: PROJECT, scopeId: "proj-uuid", source: CUSTOM }
       orderBy: { field: NAME, direction: ASC }
       first: 20
     ) {
       edges {
         node {
           id
           name
           description
           scopedPermissions {
             entityType
             operation
           }
         }
       }
       totalCount
     }
   }

3. Find roles with VFolder permissions:
   query {
     roles(
       filter: { hasPermissionFor: VFOLDER }
       first: 50
     ) {
       edges {
         node {
           id
           name
           scopedPermissions {
             entityType
             operation
           }
         }
       }
     }
   }

4. Paginated role listing:
   query {
     roles(first: 10, after: "cursor-value") {
       edges {
         node {
           id
           name
           description
         }
       }
       pageInfo {
         hasNextPage
         endCursor
       }
     }
   }
"""
type Query {
  """
  Get a specific role by ID.
  Returns null if role not found or user lacks permission.
  """
  role(id: ID!): Role

  """
  List roles with optional filtering and pagination.
  Supports cursor-based pagination following Relay specification.

  Pagination:
  - Use 'first' and 'after' for forward pagination
  - Use 'last' and 'before' for backward pagination
  - Default page size is typically 20-50 items

  Performance considerations:
  - Always use pagination for large result sets
  - Specify only needed fields to reduce response size
  - Use filters to narrow results before fetching
  """
  roles(
    """Filter criteria (all filters are ANDed together)"""
    filter: RoleFilter

    """Ordering specification"""
    orderBy: RoleOrderBy

    """Number of items to return from the start (forward pagination)"""
    first: Int

    """Cursor to start from (forward pagination)"""
    after: String

    """Number of items to return from the end (backward pagination)"""
    last: Int

    """Cursor to start from (backward pagination)"""
    before: String
  ): RoleConnection!
}

# ==============================================================================
# Root Mutation Type
# ==============================================================================

"""
Root mutation type for RBAC operations.

Mutation Examples:

1. Create a project viewer role:
   mutation {
     createRole(input: {
       name: "Project-A-Viewer"
       description: "Read-only access"
       scope: { type: PROJECT, id: "project-a" }
       scopedPermissions: [
         { entityType: VFOLDER, operation: READ }
         { entityType: COMPUTE_SESSION, operation: READ }
       ]
     }) {
       id
       name
       scopedPermissions {
         entityType
         operation
       }
     }
   }

2. Create a role with object permissions:
   mutation {
     createRole(input: {
       name: "VFolder-X-Collaborator"
       scope: { type: USER, id: "owner-uuid" }
       objectPermissions: [
         { entityType: VFOLDER, entityId: "vfolder-x", operation: READ }
         { entityType: VFOLDER, entityId: "vfolder-x", operation: UPDATE }
       ]
     }) {
       id
       name
       objectPermissions {
         entityType
         entityId
         operation
       }
       additionalScopes {
         type
         id
       }
     }
   }

3. Update role permissions:
   mutation {
     updateRole(input: {
       id: "role-uuid"
       scopedPermissions: [
         { entityType: VFOLDER, operation: READ }
         { entityType: VFOLDER, operation: UPDATE }
       ]
     }) {
       id
       scopedPermissions {
         entityType
         operation
       }
     }
   }

4. Delete a custom role:
   mutation {
     deleteRole(id: "role-uuid")
   }

5. Assign a role to a user:
   mutation {
     createRoleAssignment(input: {
       userId: "alice-uuid"
       roleId: "project-member-role-uuid"
       scope: { type: PROJECT, id: "project-a-uuid" }
     }) {
       id
       userId
       role {
         name
       }
       scope {
         type
         id
       }
       state
       grantedAt
     }
   }

6. Revoke a role assignment:
   mutation {
     deleteRoleAssignment(id: "role-assignment-uuid")
   }

Use Cases:

1. Setting Up Project Roles:
   - Create "Project-A-Admin" with full permissions
   - Create "Project-A-Member" with standard member access
   - Create "Project-A-Viewer" with read-only access

2. Resource-Specific Access:
   - Share a specific VFolder with a collaborator
   - Grant access to a specific compute session
   - Provide read access to a specific model service

3. Evolving Permissions:
   - Start with basic permissions for new team members
   - Expand permissions as they gain more responsibility
   - Remove permissions when changing roles

4. Cross-Scope Collaboration:
   - Share personal resources with project teams
   - Grant access to resources across projects
   - Enable collaborative workflows spanning multiple scopes

Best Practices:

1. Role Naming:
   - Use descriptive names: "Project-A-Member" not "role1"
   - Include scope context: "ML-Team-Viewer"
   - Be consistent across the organization

2. Permission Granularity:
   - Use scoped permissions for team-wide access
   - Use object permissions for specific resource sharing
   - Start with minimal permissions and expand as needed

3. Regular Audits:
   - Review custom roles periodically
   - Remove unused roles
   - Update permissions to match current needs
"""
type Mutation {
  """
  Create a new custom role.

  Requires: CREATE permission for role entity type in the target scope.

  Returns the created Role.
  """
  createRole(input: CreateRoleInput!): Role!

  """
  Update a role's name, description, or permissions.

  Requires: UPDATE permission for role entity type.

  Notes:
  - System sourced roles can be modified but not deleted
  - Providing scopedPermissions/objectPermissions replaces existing lists
  - All fields except 'id' are optional

  Returns the updated Role.
  """
  updateRole(input: UpdateRoleInput!): Role!

  """
  Delete a role.

  Requires: DELETE permission for role entity type.

  Notes:
  - System sourced roles cannot be deleted
  - Deletion may be prevented if role is currently assigned to users

  Returns the ID of the deleted role.
  """
  deleteRole(id: ID!): ID!

  """
  Assign a role to a user in a specific scope.

  Requires:
  - CREATE permission for role_assignment entity type
  - READ permission for the target role (prevents privilege escalation)

  Notes:
  - Creates a mapping between user and role within the specified scope
  - User immediately receives all permissions defined in the role
  - To prevent privilege escalation, you can only assign roles you have read access to

  Returns the created RoleAssignment.
  """
  createRoleAssignment(input: CreateRoleAssignmentInput!): RoleAssignment!

  """
  Revoke a role assignment (remove role from user).

  Requires: DELETE permission for role_assignment entity type

  Notes:
  - Removes the user's access to all permissions granted by this role
  - Does not affect other role assignments the user may have

  Returns the ID of the deleted role assignment.
  """
  deleteRoleAssignment(id: ID!): ID!
}

# ==============================================================================
# Role Assignment
# ==============================================================================

"""
RoleAssignmentState indicates whether the assignment is active or inactive.
"""
enum RoleAssignmentState {
  ACTIVE
  INACTIVE
}

"""
RoleAssignment: Maps a user to a role within a specific scope.

This is a separate entity that creates the connection between users and roles.
It provides flexible management without modifying the Role itself, and maintains
a complete audit trail of who granted access and when.

Example:
  User Alice is assigned "Project-A-Member" role:
  - user: "alice-uuid"
  - role: "project-a-member-role-uuid"
  - scope: { type: PROJECT, id: "project-a-uuid" }
  - state: ACTIVE
  - grantedBy: "admin-uuid"
  - grantedAt: "2025-01-15T10:30:00Z"

Result: Alice immediately has all permissions defined in "Project-A-Member" role
within the Project-A scope.
"""
type RoleAssignment {
  """Unique identifier"""
  id: ID!

  """User ID receiving the role"""
  userId: ID!

  """The role being assigned"""
  role: Role!

  """Scope where this assignment applies"""
  scope: Scope!

  """Assignment state (ACTIVE or INACTIVE)"""
  state: RoleAssignmentState!

  """User ID who granted this assignment"""
  grantedById: ID!

  """Timestamp when assignment was granted"""
  grantedAt: DateTime!

  """Optional expiration time for temporary access"""
  expiresAt: DateTime
}

"""
Input for creating a role assignment.

Example - Assign project member role:
  {
    userId: "alice-uuid",
    roleId: "project-member-role-uuid",
    scope: { type: PROJECT, id: "project-a-uuid" }
  }

Example - Temporary contractor access:
  {
    userId: "contractor-uuid",
    roleId: "project-viewer-role-uuid",
    scope: { type: PROJECT, id: "project-uuid" },
    expiresAt: "2025-12-31T23:59:59Z"
  }
"""
input CreateRoleAssignmentInput {
  """User to assign the role to"""
  userId: ID!

  """Role to assign"""
  roleId: ID!

  """Scope where the assignment applies"""
  scope: ScopeInput!

  """Optional expiration time for temporary access"""
  expiresAt: DateTime
}

# ==============================================================================
# End of Schema
# ==============================================================================
